.define public AD0_PIN 6
.define public IRQ_PIN 19
.define public IOW_PIN 4
.define public IOR_PIN 5
.define public IOCHRDY_PIN 26
.define public ADS_PIN 27
.define public BUSOE_PIN 28
.define public DACK_PIN 20

.program iow
restart:
.wrap_target
    wait 1 gpio IOW_PIN         ; IOW rising edge (or already high when PIO starts)
    wait 0 gpio IOW_PIN         ; IOW falling edge:
    jmp pin read_addr           ; if this is not during DMA (~DACK deasserted), go ahead and read address
    jmp restart                 ; otherwise restart
read_addr:
    in pins, 10                 ; Read address
    set pins, 0b11 [8]          ; Set muxes to data. Wait 8 cycles for mux to switch
    in pins, 8                  ; Read data
    set pins, 0b01              ; Set muxes back to address
    out X, 32                   ; get condition from handle_iow
    jmp !X restart              ; if we get a 0 condition from handle_iow, it's not an interesting address
    set pins, 0b00              ; set IOCHRDY low
    out null, 32                ; stall until handle_iow completes
    set pins, 0b01              ; muxes to addr, IOCHRDY high
.wrap

% c-sdk {
static inline void iow_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = iow_program_get_default_config(offset);

    // Set up AD0 pins as input
    sm_config_set_in_pins(&c, AD0_PIN);
    // Autopush at 18 bits (10 addr + 8 data)
    sm_config_set_in_shift(&c, false, true, 18);

    // Autopull 32 bits (condition variables from handle_ior)
    sm_config_set_out_shift(&c, true, true /* autopull */, 32);

    // Set the pin direction for IOW and AD0 bus as input at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, IOW_PIN, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, AD0_PIN, 10, false);

    // set up IOCHRDY and ADS
    sm_config_set_set_pins(&c, IOCHRDY_PIN, 2);
    pio_gpio_init(pio, IOCHRDY_PIN);
    pio_gpio_init(pio, ADS_PIN);
    pio_sm_set_consecutive_pindirs(pio, sm, IOCHRDY_PIN, 2, true);

    // JMP on ~DACK so we can ignore iow during DMA write
    sm_config_set_jmp_pin(&c, DACK_PIN);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}

.program ior
restart:
    set pins, 0b01              ; muxes to addr, IOCHRDY high
    wait 1 gpio IOR_PIN         ; ensure IOR high when PIO starts
.wrap_target
    wait 0 gpio IOR_PIN         ; IOR falling edge
    in pins, 10                 ; - Read address
    out X, 32                   ; stall until we get condition from handle_ior
    jmp !X restart              ; if we get a 0 condition from handle_ior, it's not an interesting address
    set pins, 0b00              ; set IOCHRDY low, muxes to addr
    out pins, 8                 ; output data to be written
    out pindirs, 8              ; next 8 in pindirs is FF - set pindirs as output
    set pins, 0b11              ; set IOCHRDY high, muxes to data
    wait 1 gpio IOR_PIN         ; - wait for IOR rising edge
    out pins, 8                 ; next 8 in pindirs is FF - reset data pins back to 0
    set pins, 0b01              ; set muxes back to address
    out pindirs, 8              ; next 8 in pindirs is 00 - set pindirs back as input
.wrap

% c-sdk {
static inline void ior_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = ior_program_get_default_config(offset);

    // sm_config_set_out_pins(&c, pin, 1);
    sm_config_set_in_pins(&c, AD0_PIN);
    sm_config_set_in_shift(&c, false, true, 10);

    // Set the pin direction to input at the PIO
    pio_sm_set_consecutive_pindirs(pio, sm, IOR_PIN, 1, false);
    pio_sm_set_consecutive_pindirs(pio, sm, AD0_PIN, 10, false);

    sm_config_set_out_pins(&c, AD0_PIN, 8);
    sm_config_set_out_shift(&c, true, true /* autopull */, 32);
    // Set this pin's GPIO function (connect PIO to the pad)
    for (int i = AD0_PIN; i <= AD0_PIN + 8; i++) {
        pio_gpio_init(pio, i);
    }

    // set up IOCHRDY and ADS
    sm_config_set_set_pins(&c, IOCHRDY_PIN, 2);
    pio_gpio_init(pio, ADS_PIN);
    pio_gpio_init(pio, IOCHRDY_PIN);
    pio_sm_set_consecutive_pindirs(pio, sm, IOCHRDY_PIN, 2, true);


    // Load our configuration, and jump to the start of the program
    // pio->input_sync_bypass = ((0x1u << IOR_PIN) | (0x3ffu << AD0_PIN));
    pio_sm_init(pio, sm, offset, &c);
    // Set the state machine running
    pio_sm_set_enabled(pio, sm, true);
}
%}
